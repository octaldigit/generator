<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neurotransmission</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #550000;
            font-family: 'Arial', sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height, centerX, centerY;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
        }

        resize();
        window.addEventListener('resize', resize);

        // Animation settings
        let animationPhase = 0; // 0: expanding (random diffusion), 1: contracting (convergence), 2: white flash, 3: resetting
        let flashOpacity = 0;
        const FLASH_DURATION_FRAMES = 30;
        let flashFrame = 0;
        let animationStartTime = Date.now();
        const MAX_ANIMATION_DURATION_MS = 20000;
        const FADE_START_RATIO = 0.7;

        // Background Noise (Particle) settings
        const BACKGROUND_PARTICLE_COUNT = 100;
        const backgroundParticles = [];
        const BG_PARTICLE_SPEED = 0.05;

        class BackgroundParticle {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = Math.random() * 1.5 + 0.5;
                this.color = `rgba(255, 255, 255, ${Math.random() * 0.15 + 0.05})`; 
            }

            update() {
                this.x += Math.cos(Date.now() * 0.0001) * BG_PARTICLE_SPEED;
                this.y += Math.sin(Date.now() * 0.0001) * BG_PARTICLE_SPEED;
                
                if (this.x < 0 || this.x > width) this.x = Math.random() * width;
                if (this.y < 0 || this.y > height) this.y = Math.random() * height;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function initBackgroundParticles() {
            backgroundParticles.length = 0; 
            for (let i = 0; i < BACKGROUND_PARTICLE_COUNT; i++) {
                backgroundParticles.push(new BackgroundParticle());
            }
        }
        
        initBackgroundParticles();
        window.addEventListener('resize', () => {
            resize();
            initBackgroundParticles(); 
        });


        class Particle {
            constructor(angle, distance, color, speed) {
                this.angle = angle;
                this.distance = distance;
                this.initialDistance = distance;
                this.color = color;
                this.speed = speed;
                this.baseSize = 5;
                this.size = this.baseSize;
                this.ellipseRatio = 1;
                this.rotation = 0;
                this.MAX_SIZE_MULTIPLIER = 3.0; // 최대 크기 제한 (300%)

                // Random diffusion properties
                const randomAngle = Math.random() * Math.PI * 2;
                this.directionX = Math.cos(randomAngle);
                this.directionY = Math.sin(randomAngle);
                this.currentX = centerX + Math.cos(this.angle) * this.distance;
                this.currentY = centerY + Math.sin(this.angle) * this.distance;

                // 움직임 랜덤성을 위한 노이즈 계수
                this.noiseOffset = Math.random() * 1000;
            }

            reset() {
                this.distance = this.initialDistance;
                this.size = this.baseSize;
                this.ellipseRatio = 1;
                this.rotation = 0; 
                this.currentX = centerX + Math.cos(this.angle) * this.distance;
                this.currentY = centerY + Math.sin(this.angle) * this.distance;
            }

            update() {
                const distanceRatio = this.distance / this.initialDistance;
                const accelerationFactor = 1.0 + Math.pow(distanceRatio * 0.5, 0.5); 
                
                // 랜덤 노이즈 추가 (시간에 따라 미세하게 방향 변경)
                const randomNoiseX = Math.sin(Date.now() * 0.001 + this.noiseOffset) * 0.05;
                const randomNoiseY = Math.cos(Date.now() * 0.001 + this.noiseOffset) * 0.05;

                if (animationPhase === 0) {
                    // Expansion: Move in random direction + micro-noise
                    this.currentX += (this.directionX + randomNoiseX) * this.speed * accelerationFactor * 0.5;
                    this.currentY += (this.directionY + randomNoiseY) * this.speed * accelerationFactor * 0.5;
                    
                    this.distance = Math.sqrt(
                        Math.pow(this.currentX - centerX, 2) + 
                        Math.pow(this.currentY - centerY, 2)
                    );
                    
                    this.rotation += 0.01;

                } else if (animationPhase === 1) {
                    // Contraction: Converge back to center
                    const dx = centerX - this.currentX;
                    const dy = centerY - this.currentY;
                    const distToCenter = Math.sqrt(dx * dx + dy * dy);

                    if (distToCenter > this.initialDistance) {
                        const normalizedDx = dx / distToCenter;
                        const normalizedDy = dy / distToCenter;
                        
                        // 수렴 시에도 노이즈를 적용하여 진동하는 듯한 느낌 부여
                        const movementFactor = this.speed * accelerationFactor * 0.5;
                        this.currentX += (normalizedDx * movementFactor) + (randomNoiseX * 0.5);
                        this.currentY += (normalizedDy * movementFactor) + (randomNoiseY * 0.5);
                        this.distance = distToCenter;
                    } else {
                        // 원래 위치에 정지
                        this.currentX = centerX + Math.cos(this.angle) * this.initialDistance;
                        this.currentY = centerY + Math.sin(this.angle) * this.initialDistance;
                        this.distance = this.initialDistance;
                    }
                    
                    this.rotation -= 0.01;
                }
                
                // 크기 제한 적용 (최대 300%)
                const calculatedSize = this.baseSize + (this.distance / this.initialDistance) * 10;
                this.size = Math.min(calculatedSize, this.baseSize * this.MAX_SIZE_MULTIPLIER);
                
                this.ellipseRatio = 1 + (this.distance / this.initialDistance) * 0.3;
            }

            draw() {
                const x = this.currentX;
                const y = this.currentY;
                
                const maxDim = Math.max(width, height);
                const fadeStart = maxDim * FADE_START_RATIO;
                
                let alpha = 1;
                if (this.distance > fadeStart) { 
                    alpha = 1 - (this.distance - fadeStart) / (maxDim - fadeStart);
                    alpha = Math.max(0, alpha); 
                }
                
                if (alpha === 0) return; 

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.rotation);
                
                ctx.globalCompositeOperation = 'lighter';
                
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                gradient.addColorStop(0, this.color.replace(')', `, ${alpha * 0.8})`));
                gradient.addColorStop(0.5, this.color.replace(')', `, ${alpha * 0.4})`));
                gradient.addColorStop(1, this.color.replace(')', `, 0)`));
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * this.ellipseRatio, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = `rgba(255, 100, 100, ${alpha * 0.6})`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * this.ellipseRatio, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            }
        }

        const particles = [];
        const PARTICLE_COLORS = [
            'rgba(255, 255, 255', 'rgba(200, 200, 200', 'rgba(150, 150, 150',
            'rgba(180, 180, 180', 'rgba(220, 220, 220', 'rgba(170, 170, 170'
        ];
        const SPIRAL_COUNT = 8;
        const PARTICLES_PER_SPIRAL = 50;

        function initParticles() {
            particles.length = 0; 
            
            for (let s = 0; s < SPIRAL_COUNT; s++) {
                const spiralOffset = (Math.PI * 2 / SPIRAL_COUNT) * s;
                const colorIndex = s % PARTICLE_COLORS.length;
                const speed = 0.25 + (s * 0.05); 
                
                for (let i = 0; i < PARTICLES_PER_SPIRAL; i++) {
                    const angle = spiralOffset + (i * 0.2); 
                    const distance = 30 + (i * 15); 
                    
                    particles.push(new Particle(
                        angle,
                        distance,
                        PARTICLE_COLORS[colorIndex],
                        speed
                    ));
                }
            }
        }

        initParticles();
        const OFF_SCREEN_THRESHOLD = 1.2; 

        function animate() {
            const currentTime = Date.now();
            const elapsedTime = currentTime - animationStartTime;
            const maxDim = Math.max(width, height);
            
            const allOffScreen = particles.every(p => p.distance > maxDim * OFF_SCREEN_THRESHOLD);
            const timeExpired = elapsedTime > MAX_ANIMATION_DURATION_MS;
            const allReturned = particles.every(p => p.distance <= p.initialDistance + 5); 
            
            // State transitions
            if (animationPhase === 0 && (allOffScreen || timeExpired)) {
                animationPhase = 1; 
            }
            
            if (animationPhase === 1 && allReturned) {
                animationPhase = 2; 
                flashFrame = 0;
            }
            
            // 1. Draw solid background and noise particles
            ctx.fillStyle = 'rgb(85, 0, 0)';
            ctx.fillRect(0, 0, width, height);

            ctx.globalCompositeOperation = 'source-over';
            backgroundParticles.forEach(p => {
                p.update();
                p.draw();
            });


            // 2. Expanding or Contracting Phase (0 or 1)
            if (animationPhase === 0 || animationPhase === 1) {
                // Trail effect overlay
                ctx.fillStyle = 'rgba(85, 0, 0, 0.05)'; 
                ctx.fillRect(0, 0, width, height);

                ctx.globalCompositeOperation = 'lighter';
                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });
            }

            // 3. White Flash Phase (2)
            else if (animationPhase === 2) {
                flashFrame++;
                flashOpacity = Math.min(1, flashFrame / FLASH_DURATION_FRAMES);
                
                // Maintain trail effect
                ctx.fillStyle = 'rgba(85, 0, 0, 0.05)';
                ctx.fillRect(0, 0, width, height);
                
                ctx.globalCompositeOperation = 'lighter';
                particles.forEach(particle => {
                    particle.draw();
                });
                
                // White flash overlay
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = `rgba(255, 255, 255, ${flashOpacity})`;
                ctx.fillRect(0, 0, width, height);
                
                if (flashOpacity >= 1) {
                    animationPhase = 3; 
                }
            }

            // 4. Reset Phase (3)
            else if (animationPhase === 3) {
                // Clear background
                ctx.fillStyle = 'rgb(85, 0, 0)';
                ctx.fillRect(0, 0, width, height);
                
                particles.forEach(particle => particle.reset()); 
                animationPhase = 0; 
                flashOpacity = 0;
                flashFrame = 0;
                animationStartTime = Date.now();
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
